// v CharacterProgressionSystem.cpp
#include "CharacterProgressionSystem.h"
#include "QuestEvents.h"
#include "Linen.h"
#include "Engine/Core/Log.h"

CharacterProgressionSystem* CharacterProgressionSystem::s_instance = nullptr;

Skill::Skill(const std::string& id, const std::string& name, const std::string& description)
    : m_id(id)
    , m_name(name)
    , m_description(description)
    , m_level(0)
{
}

CharacterProgressionSystem::CharacterProgressionSystem() {
    // Initialize member variables if needed
    m_experience = 0;
    m_level = 1;
}

CharacterProgressionSystem::~CharacterProgressionSystem() {
    // Cleanup code if needed
    Shutdown();
}

void CharacterProgressionSystem::Initialize() {
    // Subscribe to quest completed events
    m_plugin->GetEventSystem().Subscribe<QuestCompletedEvent>(
        [this](const QuestCompletedEvent& event) {
            this->HandleQuestCompleted(event);
        });
    
    LOG(Info, "Character Progression System Initialized.");
}

void CharacterProgressionSystem::Shutdown() {
    std::lock_guard<std::mutex> lock(m_mutex);
    m_skills.clear();
    m_skillLevels.clear();
    LOG(Info, "Character Progression System Shutdown.");
}

void CharacterProgressionSystem::Update(float deltaTime) {
    // Nothing to update regularly
}

bool CharacterProgressionSystem::AddSkill(const std::string& id, const std::string& name, const std::string& description) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    if (m_skills.find(id) != m_skills.end()) {
        LOG(Warning, "Skill already exists: {0}", String(id.c_str()));
        return false;
    }
    
    auto skill = std::make_unique<Skill>(id, name, description);
    m_skills[id] = std::move(skill);
    m_skillLevels[id] = 0;
    
    LOG(Info, "Added skill: {0}", String(name.c_str()));
    return true;
}

bool CharacterProgressionSystem::IncreaseSkill(const std::string& id, int amount) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_skills.find(id);
    if (it == m_skills.end()) {
        LOG(Warning, "Skill not found: {0}", String(id.c_str()));
        return false;
    }
    
    it->second->IncreaseLevel(amount);
    m_skillLevels[id] = it->second->GetLevel();
    
    LOG(Info, "Increased skill {0} by {1} to level {2}", 
        String(id.c_str()), amount, it->second->GetLevel());
    return true;
}

int CharacterProgressionSystem::GetSkillLevel(const std::string& id) const {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_skills.find(id);
    if (it == m_skills.end()) {
        return 0;
    }
    
    return it->second->GetLevel();
}

void CharacterProgressionSystem::GainExperience(int amount) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    int oldLevel = m_level;
    m_experience += amount;
    
    // Simple level up formula: level = sqrt(experience / 100)
    m_level = 1 + static_cast<int>(sqrt(m_experience / 100.0));
    
    LOG(Info, "Gained {0} XP. Total XP: {1}", amount, m_experience);
    
    if (m_level > oldLevel) {
        LOG(Info, "Level up! New level: {0}", m_level);
    }
}

int CharacterProgressionSystem::GetExperience() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    return m_experience;
}

int CharacterProgressionSystem::GetLevel() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    return m_level;
}

const std::unordered_map<std::string, int>& CharacterProgressionSystem::GetSkills() const {
    // No need to lock here as we're returning a const reference to the cached skill levels
    return m_skillLevels;
}

void CharacterProgressionSystem::HandleQuestCompleted(const QuestCompletedEvent& event) {
    if (event.experienceGained > 0) {
        GainExperience(event.experienceGained);
        LOG(Info, "Gained {0} XP from completed quest: {1}", 
            event.experienceGained, String(event.questTitle.c_str()));
    }
}

void CharacterProgressionSystem::Serialize(BinaryWriter& writer) const {
    // Implementation
}

void CharacterProgressionSystem::Deserialize(BinaryReader& reader) {
    // Implementation
}
// ^ CharacterProgressionSystem.cpp
// v CharacterProgressionSystem.h
#pragma once

#include "RPGSystem.h"
#include "QuestEvents.h"
#include "Serialization.h"

#include <unordered_map>
#include <string>
#include <mutex>
#include <vector>
#include <memory>

class Skill {
public:
    Skill(const std::string& id, const std::string& name, const std::string& description);
    
    std::string GetId() const { return m_id; }
    std::string GetName() const { return m_name; }
    std::string GetDescription() const { return m_description; }
    int GetLevel() const { return m_level; }
    
    void SetLevel(int level) { m_level = level; }
    void IncreaseLevel(int amount = 1) { m_level += amount; }
    
private:
    std::string m_id;
    std::string m_name;
    std::string m_description;
    int m_level = 0;
};

class CharacterProgressionSystem : public RPGSystem {
public:
    // Delete copy constructor and assignment operator
    CharacterProgressionSystem(const CharacterProgressionSystem&) = delete;
    CharacterProgressionSystem& operator=(const CharacterProgressionSystem&) = delete;

    // Static access method
    static CharacterProgressionSystem* GetInstance() {
        if (!s_instance) s_instance = new CharacterProgressionSystem();
        return s_instance;
    }

    // RPGSystem interface
    void Initialize() override;
    void Shutdown() override;
    void Update(float deltaTime) override;
    
    // Implement GetName from LinenSystem
    std::string GetName() const override { return "CharacterProgressionSystem"; }
    
    // Serialization override
    void Serialize(BinaryWriter& writer) const override;
    void Deserialize(BinaryReader& reader) override;
    
    // Skill management
    bool AddSkill(const std::string& id, const std::string& name, const std::string& description);
    bool IncreaseSkill(const std::string& id, int amount = 1);
    int GetSkillLevel(const std::string& id) const;
    
    // Experience management
    void GainExperience(int amount);
    int GetExperience() const;
    int GetLevel() const;
    
    // Requirements checking
    const std::unordered_map<std::string, int>& GetSkills() const;
    
    // Cleanup method
    static void Destroy() {
        delete s_instance;
        s_instance = nullptr;
    }
    
    ~CharacterProgressionSystem();

private:
    // Private constructor
    CharacterProgressionSystem();

    // Event handlers
    void HandleQuestCompleted(const QuestCompletedEvent& event);

    // Singleton Instance
    static CharacterProgressionSystem* s_instance;

    // Character data
    int m_experience = 0;
    int m_level = 1;
    std::unordered_map<std::string, std::unique_ptr<Skill>> m_skills;
    std::unordered_map<std::string, int> m_skillLevels; // Cache for requirements checking
    
    // Thread safety
    std::mutex m_mutex;
};
// ^ CharacterProgressionSystem.h
// v EventSystem.h
#pragma once

#include <functional>
#include <unordered_map>
#include <vector>
#include <typeindex>
#include <memory>
#include <mutex>
#include <queue>

// Event Priority enum class
enum class EventPriority {
    Low = 0,
    Normal = 1,
    High = 2,
    Critical = 3
};

// Base event class
class Event {
public:
    virtual ~Event() = default;
    virtual std::type_index GetType() const = 0;

    // Priority management
    EventPriority GetPriority() const { return m_priority; }
    void SetPriority(EventPriority priority) { m_priority = priority; }

protected:
    EventPriority m_priority = EventPriority::Normal;
};

// Template derived event
template <typename T>
class EventType : public Event {
public:
    std::type_index GetType() const override { return std::type_index(typeid(T)); }
};

// Event handler wrapper
class EventHandlerBase {
public:
    virtual ~EventHandlerBase() = default;
    virtual void Handle(const Event* event) const = 0;
};

template <typename T>
class EventHandler : public EventHandlerBase {
public:
    using HandlerFunc = std::function<void(const T&)>;

    EventHandler(HandlerFunc handler) : m_handler(handler) {}

    void Handle(const Event* event) const override {
        m_handler(*static_cast<const T*>(event));
    }

private:
    HandlerFunc m_handler;
};

// Optimized event system with filtering capabilities and priority support
class EventSystem {
public:
    template <typename T>
    void Subscribe(std::function<void(const T&)> handler, const std::string& filter = "") {
        static_assert(std::is_base_of<EventType<T>, T>::value, "T must derive from EventType<T>");

        std::lock_guard<std::mutex> lock(m_mutex);

        std::type_index type = std::type_index(typeid(T));
        auto handlerPtr = std::make_shared<EventHandler<T>>(handler);

        if (filter.empty()) {
            m_handlers[type].push_back(handlerPtr);
        }
        else {
            m_filteredHandlers[type][filter].push_back(handlerPtr);
        }
    }

    template <typename T>
    void Publish(const T& event, const std::string& filter = "", EventPriority priority = EventPriority::Normal) {
        static_assert(std::is_base_of<EventType<T>, T>::value, "T must derive from EventType<T>");

        std::lock_guard<std::mutex> lock(m_mutex);

        // Create a shared copy of the event
        auto eventPtr = std::make_shared<T>(event);

        // Set the priority
        eventPtr->SetPriority(priority);

        // Queue the event
        std::type_index type = std::type_index(typeid(T));
        m_eventQueue.push(QueuedEvent(eventPtr, type, filter));
    }

    template <typename T>
    void PublishImmediate(const T& event, const std::string& filter = "") {
        static_assert(std::is_base_of<EventType<T>, T>::value, "T must derive from EventType<T>");

        std::lock_guard<std::mutex> lock(m_mutex);

        // Create a shared copy of the event
        auto eventPtr = std::make_shared<T>(event);
        std::type_index type = std::type_index(typeid(T));

        // Process global handlers
        if (m_handlers.find(type) != m_handlers.end()) {
            for (const auto& handler : m_handlers[type]) {
                handler->Handle(eventPtr.get());
            }
        }

        // Process filtered handlers
        if (!filter.empty() && m_filteredHandlers.find(type) != m_filteredHandlers.end() &&
            m_filteredHandlers[type].find(filter) != m_filteredHandlers[type].end()) {
            for (const auto& handler : m_filteredHandlers[type][filter]) {
                handler->Handle(eventPtr.get());
            }
        }
    }

    void ProcessEvents() {
        std::vector<QueuedEvent> processingBatch;

        {
            std::lock_guard<std::mutex> lock(m_mutex);

            // Move all events from the priority queue to our processing batch
            while (!m_eventQueue.empty()) {
                processingBatch.push_back(m_eventQueue.top());
                m_eventQueue.pop();
            }
        }

        // Process events in priority order (highest priority first)
        for (const auto& queuedEvent : processingBatch) {
            const auto& eventPtr = queuedEvent.event;
            const auto& type = queuedEvent.type;
            const auto& filter = queuedEvent.filter;

            // Process global handlers
            if (m_handlers.find(type) != m_handlers.end()) {
                for (const auto& handler : m_handlers[type]) {
                    handler->Handle(eventPtr.get());
                }
            }

            // Process filtered handlers
            if (!filter.empty() && m_filteredHandlers.find(type) != m_filteredHandlers.end() &&
                m_filteredHandlers[type].find(filter) != m_filteredHandlers[type].end()) {
                for (const auto& handler : m_filteredHandlers[type][filter]) {
                    handler->Handle(eventPtr.get());
                }
            }
        }
    }

private:
    struct QueuedEvent {
        std::shared_ptr<Event> event;
        std::type_index type;
        std::string filter;

        // Constructor to capture priority from the event
        QueuedEvent(std::shared_ptr<Event> e, std::type_index t, const std::string& f)
            : event(e), type(t), filter(f) {
        }

        // Comparison operator for priority queue
        bool operator<(const QueuedEvent& other) const {
            // Higher priority value means higher actual priority in std::priority_queue
            return event->GetPriority() < other.event->GetPriority();
        }
    };

    std::mutex m_mutex;
    std::unordered_map<std::type_index, std::vector<std::shared_ptr<EventHandlerBase>>> m_handlers;
    std::unordered_map<std::type_index, std::unordered_map<std::string,
        std::vector<std::shared_ptr<EventHandlerBase>>>> m_filteredHandlers;

    // Priority queue for event processing
    std::priority_queue<QueuedEvent> m_eventQueue;
};

/*
How to use the prioritized event system:

For a critical event that needs immediate attention:
    QuestFailedEvent event;
    event.questId = "main_quest";
    event.reason = "Time limit exceeded";
    m_plugin->GetEventSystem().Publish(event, "", EventPriority::Critical);

For a low-priority notification:
    PlayerLevelUpEvent event;
    event.newLevel = 5;
    m_plugin->GetEventSystem().Publish(event, "", EventPriority::Low);
*/
// ^ EventSystem.h
/// v ExamplePlugin.cs
using System;
using FlaxEngine;

namespace LinenFlax
{
    /// <summary>
    /// The sample game plugin.
    /// </summary>
    /// <seealso cref="FlaxEngine.GamePlugin" />
    public class LinenFlax : GamePlugin
    {
        /// <inheritdoc />
        public LinenFlax()
        {
            _description = new PluginDescription
            {
                Name = "LinenFlax",
                Category = "Other",
                Author = "",
                AuthorUrl = null,
                HomepageUrl = null,
                RepositoryUrl = "https://github.com/FlaxEngine/LinenFlax",
                Description = "This is an example plugin project.",
                Version = new Version(0, 0, 1),
                IsAlpha = false,
                IsBeta = false,
            };
        }

        /// <inheritdoc />
        public override void Initialize()
        {
            base.Initialize();
            Debug.Log("Hello from LinenFlax plugin C# code!");
        }

        /// <inheritdoc />
        public override void Deinitialize()
        {
            Debug.Log("Goodbye from LinenFlax plugin C# code!");
            base.Deinitialize();
        }
    }
}
/// ^ ExamplePlugin.cs
// v Linen.cpp
#include "Linen.h"
#include "LinenSystemIncludes.h" // Include all systems
#include "Engine/Core/Log.h"

// int TestSystem::s_testValue = 0;
TestSystem* TestSystem::s_instance = nullptr;

Linen::Linen(const SpawnParams& params)
    : GamePlugin(params)
{
    _description.Name = TEXT("Linen");
#if USE_EDITOR
    _description.Category = TEXT("Gameplay");
    _description.Description = TEXT("Linen plugin");
    _description.Author = TEXT("ParabolicLabs");
    _description.RepositoryUrl = TEXT("");
#endif
    _description.Version = Version(1, 0, 0);
}

Linen::~Linen() {
    Deinitialize();
}
void Linen::Initialize() {
    GamePlugin::Initialize();
    
    LOG(Info, "Linen::Initialize : ran");
    
    // Initialize systems in the correct order
    TestSystem::GetInstance()->Initialize();
    
    CharacterProgressionSystem::GetInstance()->SetPlugin(this);
    CharacterProgressionSystem::GetInstance()->Initialize();
    
    QuestSystem::GetInstance()->SetPlugin(this);
    QuestSystem::GetInstance()->Initialize();
}

void Linen::Deinitialize() {
    LOG(Info, "Linen::Deinitialize : ran");
    
    // Shutdown systems in reverse order
    QuestSystem::GetInstance()->Shutdown();
    CharacterProgressionSystem::GetInstance()->Shutdown();
    TestSystem::GetInstance()->Shutdown();
    
    // Then destroy instances
    QuestSystem::Destroy();
    CharacterProgressionSystem::Destroy();
    TestSystem::Destroy();
    
    LOG(Info, "Linen Plugin Deinitialized.");
}

void Linen::Update(float deltaTime) {
    // Update all singleton systems
    TestSystem::GetInstance()->Update(deltaTime);
    CharacterProgressionSystem::GetInstance()->Update(deltaTime);
    QuestSystem::GetInstance()->Update(deltaTime);
    
    // Process events after all systems have updated
    m_eventSystem.ProcessEvents();
}

bool Linen::DetectCycle(const std::string& systemName, 
    std::unordered_set<std::string>& visited, 
    std::unordered_set<std::string>& recursionStack) {
    if (recursionStack.count(systemName)) return true;  // Cycle detected
    if (visited.count(systemName)) return false;

    visited.insert(systemName);
    recursionStack.insert(systemName);

    for (const auto& dependency : m_registeredSystems[systemName]->GetDependencies()) {
    if (DetectCycle(dependency, visited, recursionStack)) return true;
    }

    recursionStack.erase(systemName);
    return false;
}

void Linen::CalculateInitializationOrder() {
    m_initializationOrder.clear();
    
    // Topological sort of systems based on dependencies
    std::unordered_set<std::string> visited;
    std::unordered_set<std::string> inProgress;
    std::unordered_set<std::string> recursionStack;

    for (const auto& pair : m_registeredSystems) {
        if (DetectCycle(pair.first, visited, recursionStack)) {
            LOG(Error, "Cyclic dependency detected in system: {0}", String(pair.first.c_str()));
            return;
        }
    }

    std::function<void(const std::string&)> visit = [&](const std::string& systemName) {
        if (inProgress.find(systemName) != inProgress.end()) {
            LOG(Error, "Circular dependency detected for system: {0}", String(systemName.c_str()));
            return;
        }
        
        if (visited.find(systemName) != visited.end()) {
            return;
        }
        
        inProgress.insert(systemName);
        
        auto it = m_registeredSystems.find(systemName);
        if (it != m_registeredSystems.end()) {
            for (const auto& dep : it->second->GetDependencies()) {
                visit(dep);
            }
        }
        
        inProgress.erase(systemName);
        visited.insert(systemName);
        m_initializationOrder.push_back(systemName);
    };
    
    // Visit all registered systems
    for (const auto& pair : m_registeredSystems) {
        visit(pair.first);
    }
}

// template RPGSystem* Linen::GetSystem<RPGSystem>(const std::string&);
// ^ Linen.cpp
// v Linen.h
#pragma once

#include "Engine/Scripting/Plugins/GamePlugin.h"
#include "Engine/Core/Log.h"
#include "EventSystem.h"
#include "LinenSystem.h"

#include <string>
#include <unordered_set> 
#include <unordered_map>
#include <memory>
#include <vector>
#include <mutex>
#include <typeindex>
#include <functional>

// Forward declarations
class RPGSystem;
class TestSystem;
class CharacterProgressionSystem;
class QuestSystem;
class BinaryReader;
class BinaryWriter;

// Example test system
class TestSystem : public LinenSystem {
private:
    static TestSystem* s_instance;
    int _testValue;

    // Private constructor to prevent direct instantiation
    TestSystem() : _testValue(0) {}

public:
    // Delete copy constructor and assignment operator
    TestSystem(const TestSystem&) = delete;
    TestSystem& operator=(const TestSystem&) = delete;

    void Initialize() override {
        LOG(Info, "TestSystem Initialized");
        _testValue = 0;
    }
    
    void Shutdown() override {
        LOG(Info, "TestSystem Shutdown");
    }

    // Implement required abstract methods
    std::string GetName() const override { return "TestSystem"; }
    
    void Serialize(BinaryWriter& writer) const override {
        // Simple implementation
        // writer.Write(_testValue);
    }
    
    void Deserialize(BinaryReader& reader) override {
        // Simple implementation
        // reader.Read(_testValue);
    }

    // Cleanup method (important!)
    static void Destroy() {
        delete s_instance;
        s_instance = nullptr;
    }
    
    void Update(float deltaTime) override {}
    
    static TestSystem* GetInstance() {
        if (!s_instance) s_instance = new TestSystem();
        return s_instance;
    }

    bool AddValue(int value) {
        LOG(Info, "TestSystem::AddValue : starting with value: {0}", value);
        _testValue = value;
        LOG(Info, "TestSystem::AddValue : set value to: {0}", _testValue);
        return true;
    }
    
    int GetValue() const {
        LOG(Info, "TestSystem::GetValue : returning: {0}", _testValue);
        return _testValue;
    }
};

class Linen : public GamePlugin {
public:
    Linen(const SpawnParams& params);
    ~Linen();
    
    // Core plugin lifecycle
    void Initialize() override;
    void Deinitialize() override;
    void Update(float deltaTime);

    // System management
    template <typename T>
    bool RegisterSystem();
    
    template <typename T>
    bool LoadSystem();
    
    template <typename T>
    bool UnloadSystem();
    
    // Safe system access
    template <typename T>
    T* GetSystemOld();

    template <typename T>
    T* GetSystemOld(const std::string& systemName);
    
    // Thread-safe event system access
    EventSystem& GetEventSystem() { return m_eventSystem; }

    template <typename T>
    T* GetSystem() {
        LOG(Info, "Linen::GetSystem : Called for type: {0}", String(typeid(T).name()));

        if (std::is_same<T, TestSystem>::value) {
            LOG(Info, "Linen::GetSystem : Getting TestSystem instance");
            return reinterpret_cast<T*>(TestSystem::GetInstance());
        }

        if (std::is_same<T, CharacterProgressionSystem>::value) {
            LOG(Info, "Linen::GetSystem : Type match for CharacterProgressionSystem");
            return reinterpret_cast<T*>(CharacterProgressionSystem::GetInstance());
        }

        if (std::is_same<T, QuestSystem>::value) {
            LOG(Info, "Linen::GetSystem : Type match for QuestSystem");
            return reinterpret_cast<T*>(QuestSystem::GetInstance());
        }

        LOG(Warning, "Linen::GetSystem : No matching system found");
        return nullptr;
    }

private:
    // Determines correct initialization order based on dependencies
    bool DetectCycle(const std::string& systemName, 
        std::unordered_set<std::string>& visited, 
        std::unordered_set<std::string>& recursionStack);
    void CalculateInitializationOrder();

    // Organizes systems by dependencies
    std::vector<std::string> m_initializationOrder;

    // Maps for system management
    std::unordered_map<std::string, std::unique_ptr<RPGSystem>> m_registeredSystems;
    std::unordered_map<std::string, RPGSystem*> m_activeSystems;
    std::unordered_map<std::type_index, std::string> m_typeToName;

    // Thread safety
    std::mutex m_systemsMutex;

    // Centralized event system
    EventSystem m_eventSystem;
};

// Template implementations
template <typename T>
bool Linen::RegisterSystem() {
    static_assert(std::is_base_of<RPGSystem, T>::value, "T must derive from RPGSystem");
    
    std::lock_guard<std::mutex> lock(m_systemsMutex);
    
    auto system = std::make_unique<T>();
    std::string systemName = system->GetName();
    
    if (m_registeredSystems.find(systemName) != m_registeredSystems.end()) {
        LOG(Warning, "System already registered: {0}", String(systemName.c_str()));
        return false;
    }
    
    // Store type information for safer access
    m_typeToName[std::type_index(typeid(T))] = systemName;
    
    // Set plugin reference and store system
    system->SetPlugin(this);
    m_registeredSystems[systemName] = std::move(system);
    
    // Recalculate initialization order
    CalculateInitializationOrder();
    
    LOG(Info, "Registered system: {0}", String(systemName.c_str()));
    return true;
}

template <typename T>
bool Linen::LoadSystem() {
    static_assert(std::is_base_of<RPGSystem, T>::value, "T must derive from RPGSystem");
    
    std::lock_guard<std::mutex> lock(m_systemsMutex);
    
    auto typeIndex = std::type_index(typeid(T));
    
    // Check if we know about this type
    if (m_typeToName.find(typeIndex) == m_typeToName.end()) {
        LOG(Warning, "System not registered: {0}", String(typeid(T).name()));
        return false;
    }
    
    std::string systemName = m_typeToName[typeIndex];
    
    // Check if already loaded
    if (m_activeSystems.find(systemName) != m_activeSystems.end()) {
        LOG(Info, "System already loaded: {0}", String(systemName.c_str()));
        return true;
    }
    
    // Check if system is registered
    if (m_registeredSystems.find(systemName) == m_registeredSystems.end()) {
        LOG(Warning, "System not registered: {0}", String(systemName.c_str()));
        return false;
    }
    
    // First load dependencies
    auto& system = m_registeredSystems[systemName];
    for (const auto& dependency : system->GetDependencies()) {
        if (m_activeSystems.find(dependency) == m_activeSystems.end()) {
            LOG(Info, "Loading dependency: {0} for {1}", 
                String(dependency.c_str()), String(systemName.c_str()));
            
            // Find and load the dependency
            if (m_registeredSystems.find(dependency) != m_registeredSystems.end()) {
                m_registeredSystems[dependency]->Initialize();
                m_activeSystems[dependency] = m_registeredSystems[dependency].get();
            } else {
                LOG(Warning, "Missing dependency: {0}", String(dependency.c_str()));
                return false;
            }
        }
    }
    
    // Initialize the system
    system->Initialize();
    m_activeSystems[systemName] = system.get();
    
    LOG(Info, "Loaded system: {0}", String(systemName.c_str()));
    return true;
}

template <typename T>
bool Linen::UnloadSystem() {
    static_assert(std::is_base_of<RPGSystem, T>::value, "T must derive from RPGSystem");
    
    std::lock_guard<std::mutex> lock(m_systemsMutex);
    
    auto typeIndex = std::type_index(typeid(T));
    if (m_typeToName.find(typeIndex) == m_typeToName.end()) {
        LOG(Warning, "System not registered: {0}", String(typeid(T).name()));
        return false;
    }
    
    std::string systemName = m_typeToName[typeIndex];
    
    // Check if system is active
    auto it = m_activeSystems.find(systemName);
    if (it == m_activeSystems.end()) {
        LOG(Info, "System not active: {0}", String(systemName.c_str()));
        return true;
    }
    
    // Check for dependent systems
    for (const auto& pair : m_activeSystems) {
        auto& activeSystem = m_registeredSystems[pair.first];
        if (activeSystem->GetDependencies().find(systemName) != activeSystem->GetDependencies().end()) {
            LOG(Warning, "Cannot unload {0}, it is a dependency of {1}",
                String(systemName.c_str()), String(pair.first.c_str()));
            return false;
        }
    }
    
    // Shutdown the system
    m_registeredSystems[systemName]->Shutdown();
    m_activeSystems.erase(it);
    
    LOG(Info, "Unloaded system: {0}", String(systemName.c_str()));
    return true;
}

template <typename T>
T* Linen::GetSystemOld() {
    static_assert(std::is_base_of<RPGSystem, T>::value, "T must derive from RPGSystem");
    
    std::lock_guard<std::mutex> lock(m_systemsMutex);
    
    auto typeIndex = std::type_index(typeid(T));
    if (m_typeToName.find(typeIndex) == m_typeToName.end()) {
        return nullptr;
    }
    
    std::string systemName = m_typeToName[typeIndex];
    auto it = m_activeSystems.find(systemName);
    if (it == m_activeSystems.end()) {
        return nullptr;
    }
    
    return static_cast<T*>(it->second);
}

template <typename T>
T* Linen::GetSystemOld(const std::string& systemName) {
    static_assert(std::is_base_of<RPGSystem, T>::value, "T must derive from RPGSystem");

    std::lock_guard<std::mutex> lock(m_systemsMutex);

    auto it = m_activeSystems.find(systemName);
    if (it == m_activeSystems.end()) {
        return nullptr;
    }

    // Dynamic cast to ensure type safety
    return dynamic_cast<T*>(it->second);
}

// ^ Linen.h
// v LinenFlax.Build.cs
using Flax.Build;
using Flax.Build.NativeCpp;

public class LinenFlax : GameModule
{
    /// <inheritdoc />
    public override void Setup(BuildOptions options)
    {
        base.Setup(options);
        BuildNativeCode = true;
        options.PublicDefinitions.Add("COMPILE_WITH_FLAX");
    }
}
// ^ LinenFlax.Build.cs
// v LinenSystem.h
#pragma once
#include <string>

class BinaryReader;
class BinaryWriter;

// Simple base system class
class LinenSystem {
public:
    virtual ~LinenSystem() = default;
    virtual void Initialize() = 0;
    virtual void Shutdown() = 0;
    virtual void Update(float deltaTime) {}
    virtual std::string GetName() const = 0;
    
    // Serialization methods
    virtual void Serialize(BinaryWriter& writer) const { /* Default empty implementation */ }
    virtual void Deserialize(BinaryReader& reader) { /* Default empty implementation */ }
};
// ^ LinenSystem.h
#pragma once

// This file includes all system headers to avoid circular dependencies

// Include all standard library headers first
#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <memory>
#include <functional>

// Then include all system header files in proper order
#include "LinenSystem.h"
#include "RPGSystem.h"
#include "Serialization.h"
#include "QuestTypes.h"
#include "QuestEvents.h"
#include "CharacterProgressionSystem.h"
#include "QuestSystem.h"
#include "SaveLoadSystem.h"
// v LinenTest.cpp
#include "LinenTest.h"
#include "Linen.h"
#include "LinenSystemIncludes.h"
#include "Engine/Core/Log.h"
#include "Engine/Scripting/Plugins/PluginManager.h"

LinenTest::LinenTest(const SpawnParams& params)
    : Script(params)
{
    _tickUpdate = true;
}

void LinenTest::OnEnable()
{   
    try {
        LOG(Info, "LinenTest::OnEnable : Starting LinenTest");

        // Try to get the plugin from the PluginManager
        auto* plugin = PluginManager::GetPlugin<Linen>();
        
        if (plugin) {
            LOG(Info, "LinenTest::OnEnable : Found Linen Plugin!");

            // Test some functionality
            auto* questSystem = plugin->GetSystem<QuestSystem>();
            if (questSystem) {
                LOG(Info, "Quest System loaded");
                questSystem->AddQuest("test_quest", "Test Quest", "A test quest");

            } else {
                LOG(Error, "Quest System not found!");
            }

            // Test the TestSystem
            auto* testSystem = plugin->GetSystem<TestSystem>();
            if (testSystem) {
                LOG(Info, "LinenTest::OnEnable : Test System loaded");
                LOG(Info, "LinenTest::OnEnable : About to add value");
                testSystem->AddValue(42);
                
                LOG(Info, "LinenTest::OnEnable : About to get value");
                int value = testSystem->GetValue();
                LOG(Info, "LinenTest::OnEnable : Retrieved value: {0}", value);
            }
            else {
                LOG(Warning, "LinenTest::OnEnable : Test System not found");
            }
        }
        else {
            LOG(Error, "LinenTest::OnEnable : Linen Plugin not found!");
            
            // Instead of creating a local instance, we should find out why the plugin isn't registered
            LOG(Info, "LinenTest::OnEnable : TODO Checking for all available plugins");
            // This would require additional code to list all plugins
        }
    }
    catch (...) {
        LOG(Error, "LinenTest::OnEnable : Exception during Linen testing");
    }

    LOG(Info, "LinenTest::OnEnable completed");
}

void LinenTest::OnDisable()
{
    // Minimal implementation
    LOG(Info, "LinenTest::OnDisable : ran.");
}

void LinenTest::OnUpdate()
{
    // Minimal implementation
    LOG(Info, "LinenTest::OnUpdate : ran.");
}
// ^ LinenTest.cpp
// v LinenTest.h
#pragma once
#include "Engine/Scripting/Script.h"

API_CLASS() class LINENFLAX_API LinenTest : public Script
{
API_AUTO_SERIALIZATION();
DECLARE_SCRIPTING_TYPE(LinenTest);

    void OnEnable() override;
    void OnDisable() override;
    void OnUpdate() override;
};
// ^ LinenTest.h
// v QuestEvents.h
#pragma once

#include "EventSystem.h"
#include "QuestTypes.h"
#include <string>


// Event fired when a quest is completed
class QuestCompletedEvent : public EventType<QuestCompletedEvent> {
public:
    std::string questId;
    std::string questTitle;
    int experienceGained = 0;
};

// Event fired when a quest's state changes
class QuestStateChangedEvent : public EventType<QuestStateChangedEvent> {
public:
    std::string questId;
    std::string questTitle;
    QuestState oldState;
    QuestState newState;
};

// ^ QuestEvents.h
// v QuestSystem.cpp
#include "QuestSystem.h"
#include "CharacterProgressionSystem.h"
#include "Linen.h"
#include "Engine/Core/Log.h"

QuestSystem* QuestSystem::s_instance = nullptr;

Quest::Quest(const std::string& id, const std::string& title, const std::string& description)
    : m_id(id)
    , m_title(title)
    , m_description(description)
    , m_state(QuestState::Available)
    , m_experienceReward(0)
{
}


void Quest::AddSkillRequirement(const std::string& skillName, int requiredLevel) {
    m_skillRequirements[skillName] = requiredLevel;
}

bool Quest::CheckRequirements(const std::unordered_map<std::string, int>& playerSkills) const {
    for (const auto& req : m_skillRequirements) {
        auto it = playerSkills.find(req.first);
        if (it == playerSkills.end() || it->second < req.second) {
            return false;
        }
    }
    return true;
}

void Quest::Serialize(void* writer) const {
    // Serialization implementation
}

void Quest::Deserialize(void* reader) {
    // Deserialization implementation
}

QuestSystem::QuestSystem() {
    // Define system dependencies
    m_dependencies.insert("CharacterProgressionSystem");
}

QuestSystem::~QuestSystem() {
    Shutdown();
}

void QuestSystem::Initialize() {
    LOG(Info, "Quest System Initialized.");
}

void QuestSystem::Shutdown() {
    std::lock_guard<std::mutex> lock(m_mutex);
    m_quests.clear();
    LOG(Info, "Quest System Shutdown.");
}

void QuestSystem::Update(float deltaTime) {
    // Check for time-based quest updates
}

bool QuestSystem::AddQuest(const std::string& id, const std::string& title, const std::string& description) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    if (m_quests.find(id) != m_quests.end()) {
        LOG(Warning, "Quest already exists: {0}", String(id.c_str()));
        return false;
    }
    
    auto quest = std::make_unique<Quest>(id, title, description);
    m_quests[id] = std::move(quest);
    
    LOG(Info, "Added quest: {0}", String(title.c_str()));
    return true;
}

bool QuestSystem::ActivateQuest(const std::string& id) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_quests.find(id);
    if (it == m_quests.end()) {
        LOG(Warning, "Quest not found: {0}", String(id.c_str()));
        return false;
    }
    
    Quest* quest = it->second.get();
    if (quest->GetState() != QuestState::Available) {
        LOG(Warning, "Quest not available: {0}", String(id.c_str()));
        return false;
    }
    
    // Check character progression requirements
    auto progressionSystem = m_plugin->GetSystem<CharacterProgressionSystem>();
    if (progressionSystem) {
        if (!quest->CheckRequirements(progressionSystem->GetSkills())) {
            LOG(Info, "Character doesn't meet quest requirements: {0}", String(id.c_str()));
            return false;
        }
    }
    
    QuestState oldState = quest->GetState();
    quest->SetState(QuestState::Active);
    
    // Publish event without lock held
    m_mutex.unlock();
    PublishQuestStateChanged(quest, oldState);
    m_mutex.lock();
    
    LOG(Info, "Activated quest: {0}", String(id.c_str()));
    return true;
}

bool QuestSystem::CompleteQuest(const std::string& id) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_quests.find(id);
    if (it == m_quests.end()) {
        LOG(Warning, "Quest not found: {0}", String(id.c_str()));
        return false;
    }
    
    Quest* quest = it->second.get();
    if (quest->GetState() != QuestState::Active) {
        LOG(Warning, "Quest not active: {0}", String(id.c_str()));
        return false;
    }
    
    QuestState oldState = quest->GetState();
    quest->SetState(QuestState::Completed);
    
    // Release lock before event publishing to prevent deadlocks
    m_mutex.unlock();
    
    // Publish completion event
    QuestCompletedEvent event;
    event.questId = id;
    event.questTitle = quest->GetTitle();
    event.experienceGained = quest->GetExperienceReward();
    
    m_plugin->GetEventSystem().Publish(event);
    
    // Publish state change event
    PublishQuestStateChanged(quest, oldState);
    
    // Reacquire lock
    m_mutex.lock();
    
    LOG(Info, "Completed quest: {0}", String(id.c_str()));
    return true;
}

bool QuestSystem::FailQuest(const std::string& id) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_quests.find(id);
    if (it == m_quests.end()) {
        LOG(Warning, "Quest not found: {0}", String(id.c_str()));
        return false;
    }
    
    Quest* quest = it->second.get();
    if (quest->GetState() != QuestState::Active) {
        LOG(Warning, "Quest not active: {0}", String(id.c_str()));
        return false;
    }
    
    QuestState oldState = quest->GetState();
    quest->SetState(QuestState::Failed);
    
    // Publish event without lock held
    m_mutex.unlock();
    PublishQuestStateChanged(quest, oldState);
    m_mutex.lock();
    
    LOG(Info, "Failed quest: {0}", String(id.c_str()));
    return true;
}

Quest* QuestSystem::GetQuest(const std::string& id) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    auto it = m_quests.find(id);
    if (it == m_quests.end()) {
        return nullptr;
    }
    
    return it->second.get();
}

std::vector<Quest*> QuestSystem::GetAvailableQuests() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    std::vector<Quest*> result;
    for (const auto& pair : m_quests) {
        if (pair.second->GetState() == QuestState::Available) {
            result.push_back(pair.second.get());
        }
    }
    
    return result;
}

std::vector<Quest*> QuestSystem::GetActiveQuests() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    std::vector<Quest*> result;
    for (const auto& pair : m_quests) {
        if (pair.second->GetState() == QuestState::Active) {
            result.push_back(pair.second.get());
        }
    }
    
    return result;
}

std::vector<Quest*> QuestSystem::GetCompletedQuests() const {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    std::vector<Quest*> result;
    for (const auto& pair : m_quests) {
        if (pair.second->GetState() == QuestState::Completed) {
            result.push_back(pair.second.get());
        }
    }
    
    return result;
}

void QuestSystem::PublishQuestStateChanged(Quest* quest, QuestState oldState) {
    QuestStateChangedEvent event;
    event.questId = quest->GetId();
    event.questTitle = quest->GetTitle();
    event.oldState = oldState;
    event.newState = quest->GetState();
    
    m_plugin->GetEventSystem().Publish(event);
}

void QuestSystem::Serialize(BinaryWriter& writer) const {
    // Implementation
}

void QuestSystem::Deserialize(BinaryReader& reader) {
    // Implementation
}
// ^ QuestSystem.cpp
// v QuestSystem.h
#pragma once

#include "RPGSystem.h"
#include "QuestEvents.h"
#include "QuestTypes.h"
#include "Serialization.h"

#include <vector>
#include <string>
#include <mutex>
#include <unordered_map>
#include <memory>

// Forward declaration
class CharacterProgressionSystem;

class Quest {
public:
    enum class State { Available, Active, Completed, Failed };
    
    Quest(const std::string& id, const std::string& title, const std::string& description);
    
    // Getters/Setters
    std::string GetId() const { return m_id; }
    std::string GetTitle() const { return m_title; }
    std::string GetDescription() const { return m_description; }
    QuestState GetState() const { return m_state; }
    int GetExperienceReward() const { return m_experienceReward; }
    
    void SetState(QuestState state) { m_state = state; }
    void SetExperienceReward(int reward) { m_experienceReward = reward; }
    
    // Add required skill check
    void AddSkillRequirement(const std::string& skillName, int requiredLevel);
    
    // Check if player meets skill requirements
    bool CheckRequirements(const std::unordered_map<std::string, int>& playerSkills) const;
    
    // For serialization
    virtual void Serialize(void* writer) const;
    virtual void Deserialize(void* reader);
    
private:
    std::string m_id;
    std::string m_title;
    std::string m_description;
    QuestState m_state;
    int m_experienceReward;
    
    // Requirements to take/complete the quest
    std::unordered_map<std::string, int> m_skillRequirements;
};

class QuestSystem : public RPGSystem {
public:
    // Delete copy constructor and assignment operator
    QuestSystem(const QuestSystem&) = delete;
    QuestSystem& operator=(const QuestSystem&) = delete;

    // RPGSystem interface
    void Initialize() override;
    void Shutdown() override;
    void Update(float deltaTime) override;
    
    // Implement GetName from LinenSystem
    std::string GetName() const override { return "QuestSystem"; }
    
    // Serialization override
    void Serialize(BinaryWriter& writer) const override;
    void Deserialize(BinaryReader& reader) override;
    
    // Quest management
    bool AddQuest(const std::string& id, const std::string& title, const std::string& description);
    bool ActivateQuest(const std::string& id);
    bool CompleteQuest(const std::string& id);
    bool FailQuest(const std::string& id);
    
    // Quest queries
    Quest* GetQuest(const std::string& id);
    std::vector<Quest*> GetAvailableQuests() const;
    std::vector<Quest*> GetActiveQuests() const;
    std::vector<Quest*> GetCompletedQuests() const;

    // Static access method
    static QuestSystem* GetInstance() {
        if (!s_instance) s_instance = new QuestSystem();
        return s_instance;
    }
    
    // Cleanup method
    static void Destroy() {
        delete s_instance;
        s_instance = nullptr;
    }
    
    ~QuestSystem();
    
private:
    // Private constructor
    QuestSystem();

    // Internal helper methods
    void PublishQuestStateChanged(Quest* quest, QuestState oldState);
    
    // Singleton instance
    static QuestSystem* s_instance;
    
    // Quest storage
    std::unordered_map<std::string, std::unique_ptr<Quest>> m_quests;
    
    // Thread safety
    std::mutex m_mutex;
};
// ^ QuestSystem.h
// v QuestTypes.h
#pragma once

// Forward declarations and common types for Quest-related classes
class Quest;

// Quest state enum that can be used by multiple files
enum class QuestState {
    Available,
    Active, 
    Completed,
    Failed
};
// ^ QuestTypes.h
// v RPGSystem.h
#pragma once

#include <string>
#include <vector>
#include <unordered_set>

#include "LinenSystem.h"

// Forward declaration
class Linen;
class BinaryReader;
class BinaryWriter;

// Base class for all RPG systems
class RPGSystem : public LinenSystem {
public:
    virtual ~RPGSystem() = default;
    
    // System dependencies
    const std::unordered_set<std::string>& GetDependencies() const { return m_dependencies; }
    
    // Plugin reference for accessing other systems
    void SetPlugin(Linen* plugin) { m_plugin = plugin; }

protected:
    Linen* m_plugin = nullptr;
    std::unordered_set<std::string> m_dependencies;
};
// ^ RPGSystem.h
// v SaveLoadSystem.cpp
#include "SaveLoadSystem.h"
#include "Linen.h"
#include "LinenSystemIncludes.h"
#include "Engine/Core/Log.h"
#include <fstream>

SaveLoadSystem* SaveLoadSystem::s_instance = nullptr;

void SaveLoadSystem::Initialize() {
    LOG(Info, "Save/Load System Initialized.");
}

void SaveLoadSystem::Shutdown() {
    std::lock_guard<std::mutex> lock(m_mutex);
    m_serializableSystems.clear();
    LOG(Info, "Save/Load System Shutdown.");
}

void SaveLoadSystem::Update(float deltaTime) {
    // Nothing to update regularly
}


bool SaveLoadSystem::SaveGame(const std::string& filename) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // Create a writer object (implementation specific)
    // void* writer = CreateWriter(filename);
    
    LOG(Info, "Saving game to: {0}", String(filename.c_str()));
    
    // For each registered system, call its Serialize method
    for (const auto& systemName : m_serializableSystems) {
        // FIX: Removed the string parameter
        auto system = m_plugin->GetSystem<RPGSystem>();
        if (system) {
            // Call system-specific serialization
            // system->Serialize(writer);
            LOG(Info, "Saved system: {0}", String(systemName.c_str()));
        }
    }
    
    // Close writer
    // CloseWriter(writer);
    
    LOG(Info, "Game saved successfully: {0}", String(filename.c_str()));
    return true;
}

bool SaveLoadSystem::LoadGame(const std::string& filename) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // Create a reader object (implementation specific)
    // void* reader = CreateReader(filename);
    // if (!reader) {
    //     LOG(Error, "Failed to open save file: {0}", String(filename.c_str()));
    //     return false;
    // }
    
    LOG(Info, "Loading game from: {0}", String(filename.c_str()));
    
    // For each registered system, call its Deserialize method
    for (const auto& systemName : m_serializableSystems) {
        // FIX: Removed the string parameter
        auto system = m_plugin->GetSystem<RPGSystem>();
        if (system) {
            // Call system-specific deserialization
            // system->Deserialize(reader);
            LOG(Info, "Loaded system: {0}", String(systemName.c_str()));
        }
    }
    
    // Close reader
    // CloseReader(reader);
    
    LOG(Info, "Game loaded successfully: {0}", String(filename.c_str()));
    return true;
}

void SaveLoadSystem::RegisterSerializableSystem(const std::string& systemName) {
    std::lock_guard<std::mutex> lock(m_mutex);
    m_serializableSystems.insert(systemName);
    LOG(Info, "Registered system for serialization: {0}", String(systemName.c_str()));
}
// ^ SaveLoadSystem.h
// v SaveLoadSystem.h
#pragma once

#include "RPGSystem.h"
#include <string>
#include <mutex>
#include <unordered_set>
#include <functional>


class SaveLoadSystem : public RPGSystem {
public:
    
    // Delete copy constructor and assignment operator
    SaveLoadSystem(const SaveLoadSystem&) = delete;
    SaveLoadSystem& operator=(const SaveLoadSystem&) = delete;

    // RPGSystem interface
    void Initialize() override;
    void Shutdown() override;
    void Update(float deltaTime) override;

    std::string GetName() const override { return "SaveLoadSystem"; }
    
    // Save/Load functionality
    bool SaveGame(const std::string& filename);
    bool LoadGame(const std::string& filename);
    
    // System registration for save/load
    void RegisterSerializableSystem(const std::string& systemName);
    
    // Default serialization - can be overridden by systems
    virtual void Serialize(BinaryWriter& writer) const override {}
    virtual void Deserialize(BinaryReader& reader) override {}
    
    // Static access method
    static SaveLoadSystem* GetInstance() {
        if (!s_instance) s_instance = new SaveLoadSystem();
        return s_instance;
    }

    // Cleanup method
    static void Destroy() {
        delete s_instance;
        s_instance = nullptr;
    }
    
    ~SaveLoadSystem() {
        Shutdown();
    }

private:
    SaveLoadSystem() {};
    
    // Singleton Instance
    static SaveLoadSystem* s_instance;

    // Thread safety
    std::mutex m_mutex;
    
    // Track which systems need serialization
    std::unordered_set<std::string> m_serializableSystems;
};
// ^ SaveLoadSystem.h
// v Serialization.h

#pragma once

#include "LinenSystem.h"
#include <string>
#include <vector>
#include <unordered_map>
#include <fstream>
#include <cstdint>

class BinaryWriter {
public:
    BinaryWriter(const std::string& filename) : m_stream(filename, std::ios::binary | std::ios::out) {}
    ~BinaryWriter() { m_stream.close(); }
    
    bool IsValid() const { return m_stream.good(); }
    
    // Write primitives
    void Write(bool value) { Write(&value, sizeof(bool)); }
    void Write(int32_t value) { Write(&value, sizeof(int32_t)); }
    void Write(uint32_t value) { Write(&value, sizeof(uint32_t)); }
    void Write(float value) { Write(&value, sizeof(float)); }
    void Write(double value) { Write(&value, sizeof(double)); }
    
    // Write string
    void Write(const std::string& value) {
        uint32_t length = static_cast<uint32_t>(value.length());
        Write(length);
        if (length > 0) {
            Write(value.data(), length);
        }
    }
    
    // Write raw data
    void Write(const void* data, size_t size) {
        m_stream.write(static_cast<const char*>(data), size);
    }
    
    // Write container helpers
    template<typename T>
    void WriteVector(const std::vector<T>& vec) {
        uint32_t size = static_cast<uint32_t>(vec.size());
        Write(size);
        for (const auto& item : vec) {
            Write(item);
        }
    }
    
    // Write vector of serializable objects
    template<typename T>
    void WriteSerializableVector(const std::vector<std::unique_ptr<T>>& vec) {
        uint32_t size = static_cast<uint32_t>(vec.size());
        Write(size);
        for (const auto& item : vec) {
            item->Serialize(*this);
        }
    }
    
    // Write map
    template<typename K, typename V>
    void WriteMap(const std::unordered_map<K, V>& map) {
        uint32_t size = static_cast<uint32_t>(map.size());
        Write(size);
        for (const auto& pair : map) {
            Write(pair.first);
            Write(pair.second);
        }
    }
    
private:
    std::ofstream m_stream;
};

class BinaryReader {
public:
    BinaryReader(const std::string& filename) : m_stream(filename, std::ios::binary | std::ios::in) {}
    ~BinaryReader() { m_stream.close(); }
    
    bool IsValid() const { return m_stream.good() && !m_stream.eof(); }
    
    // Read primitives
    void Read(bool& value) { Read(&value, sizeof(bool)); }
    void Read(int32_t& value) { Read(&value, sizeof(int32_t)); }
    void Read(uint32_t& value) { Read(&value, sizeof(uint32_t)); }
    void Read(float& value) { Read(&value, sizeof(float)); }
    void Read(double& value) { Read(&value, sizeof(double)); }
    
    // Read string
    void Read(std::string& value) {
        uint32_t length = 0;
        Read(length);
        value.resize(length);
        if (length > 0) {
            Read(&value[0], length);
        }
    }
    
    // Read raw data
    void Read(void* data, size_t size) {
        m_stream.read(static_cast<char*>(data), size);
    }
    
    // Read container helpers
    template<typename T>
    void ReadVector(std::vector<T>& vec) {
        uint32_t size = 0;
        Read(size);
        vec.resize(size);
        for (uint32_t i = 0; i < size; ++i) {
            Read(vec[i]);
        }
    }
    
    // Read vector of serializable objects
    template<typename T>
    void ReadSerializableVector(std::vector<std::unique_ptr<T>>& vec) {
        uint32_t size = 0;
        Read(size);
        vec.clear();
        for (uint32_t i = 0; i < size; ++i) {
            auto item = std::make_unique<T>();
            item->Deserialize(*this);
            vec.push_back(std::move(item));
        }
    }
    
    // Read map
    template<typename K, typename V>
    void ReadMap(std::unordered_map<K, V>& map) {
        uint32_t size = 0;
        Read(size);
        map.clear();
        K key;
        V value;
        for (uint32_t i = 0; i < size; ++i) {
            Read(key);
            Read(value);
            map[key] = value;
        }
    }
    
private:
    std::ifstream m_stream;
};
// ^ Serialization.h
